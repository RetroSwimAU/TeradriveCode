#include <types.h>
#include "vga.h"
#include "teradrive.h"

// VGA Ports and register counts. Taken from 
// https://github.com/jedld/dex-os/blob/master/hardware/vga/dexvga.c
// Verified against TeraDrive VGA chip datasheet, WD90C10.
#define VGA_AC_INDEX 0x3C0
#define VGA_AC_WRITE 0x3C0
#define VGA_AC_READ 0x3C1
#define VGA_MISC_WRITE 0x3C2
#define VGA_SEQ_INDEX 0x3C4
#define VGA_SEQ_DATA 0x3C5
#define VGA_DAC_READ_INDEX 0x3C7
#define VGA_DAC_WRITE_INDEX 0x3C8
#define VGA_DAC_DATA 0x3C9
#define VGA_MISC_READ 0x3CC
#define VGA_GC_INDEX 0x3CE
#define VGA_GC_DATA 0x3CF
#define VGA_CRTC_INDEX 0x3D4 /* 0x3B4 */
#define VGA_CRTC_DATA 0x3D5 /* 0x3B5 */
#define VGA_INSTANT_READ 0x3DA
#define VGA_NUM_SEQ_REGS 5
#define VGA_NUM_CRTC_REGS 25
#define VGA_NUM_GC_REGS 9
#define VGA_NUM_AC_REGS 21
#define VGA_NUM_REGS (1 + VGA_NUM_SEQ_REGS + VGA_NUM_CRTC_REGS + VGA_NUM_GC_REGS + VGA_NUM_AC_REGS)

#define VRAM_BACKUP_LOCATION 0x7E00
#define PALETTE_BACKUP_LOCATION 0x17E00

// VGA register dumps from my actual system.
unsigned char graphics_31KHZ[] = {
	0x63,0x03,0x01,0x0f,0x00,0x0e,0x5f,0x4f,
	0x50,0x82,0x54,0x80,0xbf,0x1f,0x00,0x41,
	0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0xae,
	0x8f,0x28,0x40,0x96,0xb9,0xa3,0xff,0x00,
	0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x41,0x00,0x0f,0x00,0x00	
};

unsigned char graphics_15KHZ[] = {
	0xeb,0x03,0x01,0x0f,0x00,0x0e,0x6d,0x4f,
	0x50,0x90,0x5a,0xa4,0x04,0x01,0x00,0x40,
	0x06,0x07,0x00,0x00,0x00,0x00,0xdb,0xad,
	0xc7,0x28,0x40,0xcb,0xfe,0xa3,0xfe,0x00,
	0x00,0x00,0x00,0x00,0x40,0x05,0x0f,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x41,0x00,0x0f,0x00,0x00
};

unsigned char col80_31KHZ[] = {
	0x67,0x03,0x00,0x03,0x00,0x02,0x5f,0x4f,
	0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,
	0x0d,0x0e,0x00,0x00,0x00,0x00,0x9c,0xae,
	0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xff,0x00,
	0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x0c,0x00,0x0f,0x08,0x00
};

unsigned char col80_15KHZ[] = {
	0xeb,0x03,0x01,0x03,0x00,0x02,0x6d,0x4f,
	0x50,0x90,0x5b,0xa5,0x04,0x01,0x00,0x47,
	0x06,0x07,0x00,0x00,0x00,0x00,0xdb,0xad,
	0xc7,0x28,0x1f,0xcb,0xfe,0xa3,0xfe,0x00,
	0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x08,0x00,0x0f,0x00,0x00
};

unsigned char col40_31KHZ[] = {
	0x67,0x03,0x08,0x03,0x00,0x02,0x2d,0x27,
	0x28,0x90,0x2b,0xa0,0xbf,0x1f,0x00,0x4f,
	0x0d,0x0e,0x00,0x00,0x00,0x00,0x9c,0xae,
	0x8f,0x14,0x1f,0x96,0xb9,0xa3,0xff,0x00,
	0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
	0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x0c,0x00,0x0f,0x08,0x00
};

unsigned char col40_15KHZ[] = {
	0xeb,0x03,0x09,0x03,0x00,0x02,0x34,0x27,
	0x28,0x97,0x2e,0xb3,0x04,0x01,0x00,0x47,
	0x06,0x07,0x00,0x00,0x00,0x00,0xdb,0xad,
	0xc7,0x14,0x1f,0xcb,0xfe,0xa3,0xfe,0x00,
	0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0xff,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x08,0x00,0x0f,0x00,0x00
};

void write_registers(unsigned char *regs)
{
	unsigned i;

	/* write MISCELLANEOUS reg */
	PC_IOPortWriteB(VGA_MISC_WRITE, *regs);
	regs++;
	/* write SEQUENCER regs */
	for (i = 0; i < VGA_NUM_SEQ_REGS; i++)
	{
		PC_IOPortWriteB(VGA_SEQ_INDEX, i);
		PC_IOPortWriteB(VGA_SEQ_DATA, *regs);
		regs++;
	}
	/* unlock CRTC registers */
	PC_IOPortWriteB(VGA_CRTC_INDEX, 0x03);
	PC_IOPortWriteB(VGA_CRTC_DATA, PC_IOPortReadB(VGA_CRTC_DATA) | 0x80);
	PC_IOPortWriteB(VGA_CRTC_INDEX, 0x11);
	PC_IOPortWriteB(VGA_CRTC_DATA, PC_IOPortReadB(VGA_CRTC_DATA) & ~0x80);
	/* make sure they remain unlocked */
	regs[0x03] |= 0x80;
	regs[0x11] &= ~0x80;
	/* write CRTC regs */
	for (i = 0; i < VGA_NUM_CRTC_REGS; i++)
	{
		PC_IOPortWriteB(VGA_CRTC_INDEX, i);
		PC_IOPortWriteB(VGA_CRTC_DATA, *regs);
		regs++;
	}
	/* write GRAPHICS CONTROLLER regs */
	for (i = 0; i < VGA_NUM_GC_REGS; i++)
	{
		PC_IOPortWriteB(VGA_GC_INDEX, i);
		PC_IOPortWriteB(VGA_GC_DATA, *regs);
		regs++;
	}
	/* write ATTRIBUTE CONTROLLER regs */
	(void)PC_IOPortReadB(VGA_INSTANT_READ);
	for (i = 0; i < VGA_NUM_AC_REGS; i++)
	{
		PC_IOPortWriteB(VGA_AC_INDEX, i);
		PC_IOPortWriteB(VGA_AC_WRITE, *regs);
		regs++;
	}

	/* lock 16-color palette and unblank display */
	// (void)PC_IOPortReadB(VGA_INSTANT_READ);
	PC_IOPortWriteB(VGA_AC_INDEX, 0x20);
}

/**
* Note here the vga struct must have the width 320 and height of 200
* color mode is 256
*/
void VGA_mode(u8 mode, u8 switchPosRGB)
{
	if(switchPosRGB){
		switch(mode){
			case 0x13:
				write_registers(graphics_31KHZ);
				break;
			case 0x03:
				write_registers(col80_31KHZ);
				break;
			case 0x01:
				write_registers(col40_31KHZ);
				break;
		}
	} else {
		switch(mode){
			case 0x13: 
				write_registers(graphics_15KHZ);
				break;
			case 0x03:
				write_registers(col80_15KHZ);
				break;
			case 0x01:
				write_registers(col40_15KHZ);
				break;
		}
	}
	
}

void VGA_fontBackup(){
	vu8 *p1;
    p1 = (u8*) PC_MEMORY_BASE + VRAM_BACKUP_LOCATION;
    
	vu8 *p2;
    p2 = (u8*) PC_MEMORY_BASE + 0xA0000;
    
	for(int i = 0; i < 0x1FFFF; i++){
		*p1 = *p2;
		p1++;
		p2++;
	}

}

void VGA_fontRestore(){
	vu8 *p1;
    p1 = (u8*) PC_MEMORY_BASE + VRAM_BACKUP_LOCATION;
    
	vu8 *p2;
    p2 = (u8*) PC_MEMORY_BASE + 0xA0000;
    
	for(int i = 0; i < 0x1FFFF; i++){
		*p2 = *p1;
		p1++;
		p2++;
	}

}

void VGA_paletteBackup(){
	PC_IOPortWriteB(VGA_DAC_READ_INDEX, 0x00);
	vu8 *p1;
    p1 = (u8*) PC_MEMORY_BASE + PALETTE_BACKUP_LOCATION;
    for(u16 i = 0; i < 0x100; i++){
		for(u8 j = 0; j < 3; j++){
			*p1 = PC_IOPortReadB(VGA_DAC_DATA);
			p1++;
		}
	}
}

void VGA_paletteRestore(){
PC_IOPortWriteB(VGA_DAC_WRITE_INDEX, 0x00);
	vu8 *p1;
    p1 = (u8*) PC_MEMORY_BASE + PALETTE_BACKUP_LOCATION;
    for(u16 i = 0; i < 0x100; i++){
		for(u8 j = 0; j < 3; j++){
			PC_IOPortWriteB(VGA_DAC_DATA, *p1);
			p1++;
		}
	}
}